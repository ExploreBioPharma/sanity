// @flow
import parse from './operation/parse'
import ImmutableAccessor from './ImmutableAccessor'
import {Matcher} from '../jsonpath'
import {concatAllTargets} from './operation/util'
import ChangeSet from '../changes/ChangeSet'

export default class Patcher {
  patches : Array<Object>
  constructor(patch : Object) {
    this.patches = parse(patch)
  }
  // value is the value that is to be patched, reporter is an optional callback that will be called
  // with an array of simple/Changes that describe the actual changes that was applied.
  apply(value : Object, changeSet : ChangeSet) {
    // Apply just makes a root accessor around the provided
    // value, then applies the patches. Due to the use of
    // ImmutableAccessor it is guaranteed to return either the
    // exact same object it was provided (in the case of no changes),
    // or a completely new object. It will never mutate the object in place.
    const accessor = new ImmutableAccessor(value)
    return this.applyViaAccessor(accessor, changeSet).get()
  }
  // If you want to use your own accessor implementation, you can use this method
  // to invoke the patcher. Since all subsequent accessors for children of this accessor
  // are obtained through the methods in the accessors, you retain full control of the
  // implementation throguhgout the application. Have a look in ImmutableAccessor
  // to see an example of how accessors are implemented.
  applyViaAccessor(accessor : Object, changeSet : ChangeSet) {
    let result = accessor
    const idAccessor = accessor.getAttribute('_id')
    let id
    if (idAccessor) {
      id = idAccessor.get()
    } else {
      throw new Error('Cannot apply patch to document with no _id')
    }
    // To avoid handling the potential of missing changeSets in all patch operation
    // implementation, we'll just create a throw-away change set if the client did not
    // supply one.
    const activeChangeSet = changeSet ? changeSet : new ChangeSet()
    this.patches.forEach(patch => {
      if (patch.id !== id) {
        // Ignore patches that are not targeted at this document
        return
      }
      const matcher = Matcher.fromPath(patch.path).setPayload(patch)
      result = process([], matcher, result, activeChangeSet)
    })
    return result
  }
}

// Recursively (depth first) follows any leads generated by the matcher, expecting
// a patch to be the payload. When matchers report a delivery, the
// apply(targets, accessor) is called on the patch
function process(path, matcher, accessor, changeSet) {
  let result = accessor
  // Every time we execute the matcher a new set of leads is generated. Each lead
  // is a target (being an index, an attribute name or a range) in the form of an
  // Expression instance. For each lead target there is also a matcher. Our job is to obtain
  // accessor(s) for each target (there might be more than one, since the targets may
  // be ranges) and run the provided matcher on those accessors.
  const {leads, delivery} = matcher.match(accessor)
  leads.forEach(lead => {
    if (lead.target.isIndexReference()) {
      lead.target.toIndicies().forEach(i => {
        result = result.setIndexAccessor(i, process(path.concat(i), lead.matcher, result.getIndex(i), changeSet))
      })
    } else if (lead.target.isAttributeReference()) {
      if (!result.hasAttribute(lead.target.name())) {
        // Don't follow lead, no such attribute
        return
      }
      const oldValueAccessor = result.getAttribute(lead.target.name())
      const newValueAccessor = process(path.concat(lead.target.name()), lead.matcher, result.getAttribute(lead.target.name()), changeSet)
      if (oldValueAccessor !== newValueAccessor) {
        result = result.setAttributeAccessor(lead.target.name(), newValueAccessor)
      }
    } else {
      throw new Error(`Unable to handle target ${lead.target.toString()}`)
    }
  })
  // Each time we run the matcher, we might also get a delivery. This means that a
  // term in the jsonpath terminated here and the patch should be applied. The delivery
  // arrives in the form of an array of targets and a payload (which in this application
  // is the patch). Conveniently the patches accept an array of targets and an accessor
  // to do its work, so here we just pass those to the patch and we're done.
  if (delivery) {
    const patch = delivery.payload
    result = patch.apply(delivery.targets, result, path, changeSet)
  }
  return result
}
